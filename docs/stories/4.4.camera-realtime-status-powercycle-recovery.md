# Story 4.4: 카메라 상태 실시간 반영(전원 사이클 복구) — digiCamControl 패턴 1:1 재현

## Status

In Progress

## Story

**As a** 부스 운영자,  
**I want** 카메라 전원 사이클(OFF→ON, ON→OFF→ON) 이후에도 Boothy가 실카메라 상태를 실시간으로 반영하고 자동 복구하도록 하고,  
**so that** 앱 재시작/수동 새로고침 없이 고객 모드의 카메라 램프가 신뢰 가능한 상태를 유지한다.

## Context / Problem

카메라 전원 사이클 이후 “실제로는 복구되었는데 UI 램프가 stale(빨강 고정 등)”로 남는 문제가 **수차례 재발**했다.

- (관측) OFF→ON, ON→OFF→ON 시나리오에서 램프가 초록으로 복귀하지 않음
  - [Source: `docs/problem_history/2026-01-30-camera-lamp-power-cycle-stuck.md`]
- (관측) 어떤 케이스에서는 `camera.getStatus`가 딱 1회만 호출되고, 이후 폴링/힌트가 사라져 “상태 갱신 트리거” 자체가 끊김
  - [Source: `docs/problem_history/2026-01-30-camera-lamp-power-cycle-stuck.md`]
- (원인 축) headless(.NET)에서는 EDSDK 이벤트 전달이 WPF 메시지 루프/STA 같은 “실행 조건”에 의존할 가능성이 높음
  - [Source: `docs/architecture/camera-status-realtime.md`]

따라서 이 스토리는 “UI 렌더/폴링 미세조정”이 아니라, **잘 동작하는 레퍼런스(digiCamControl)의 동작 패턴을 근거로** 상태 동기화 경로를 재설계한다.

## Approach (Reference-backed, Reuse-first)

레퍼런스 `reference/camerafunction/digiCamControl-2.0.0`의 핵심은 “이벤트를 힌트로 받고, 즉시 재열거(enumerate)로 상태를 확정”하는 것이다.

- (레퍼런스 패턴) `CameraAdded` → 즉시 `GetCameraCollection()`(재열거) → 상태 확정
  - [Source: `reference/camerafunction/digiCamControl-2.0.0/Canon.Eos.Framework/EosFramework.cs`]
  - [Source: `reference/camerafunction/digiCamControl-2.0.0/CameraControl.Devices/CameraDeviceManager.cs`]
- (Boothy 적용 원칙) “보장된 기능”을 재발명하지 않고, `reference/camerafunction/digiCamControl-2.0.0`의 구현을 **가능한 그대로 활용**한다.
  - 변경은 Boothy IPC/로그/헤드리스(headless) 실행 조건을 만족시키기 위한 **래핑/어댑터/설정 파라미터** 수준으로 제한한다.
  - 오픈소스 라이선스/고지/소스 제공 등 컴플라이언스는 본 스토리의 Dependencies/태스크에서 명시적으로 처리한다.
  - [Source: `docs/architecture/camera-status-realtime.md`]

## Acceptance Criteria

1. (OFF→ON) Given 카메라 OFF 상태에서 앱을 실행했을 때, When 카메라 전원을 ON 하면, Then **10초 이내** UI 램프가 빨강→초록으로 전환된다(앱 재시작/수동 새로고침 없이).
2. (ON→OFF→ON) Given 카메라 ON 상태에서 앱을 실행해 초록을 확인했을 때, When OFF→ON 전원 사이클을 하면, Then OFF는 **1초 이내** 빨강, ON 복귀는 **10초 이내** 초록으로 전환된다.
3. Given sidecar가 EDSDK 로딩 실패/아키텍처 불일치 등으로 real 모드가 불가능할 때, Then `boothy-camera-status`(스냅샷) 및 admin 진단 화면/로그에서 `mode`, `sdk.diagnostic` 등 **원인이 즉시 식별 가능**하다.
4. Given 전원 사이클 중 native call hang으로 `camera.getStatus`가 응답하지 않을 때, Then **2.5초 이내 Timeout 응답** 후 sidecar가 종료되고(기존 watchdog 사용), Boothy가 sidecar 재시작으로 복구를 시도한다.
5. Given 힌트 이벤트가 연속으로 발생할 때, Then probe/enumeration은 **코얼레싱/디바운스**되어 이벤트 폭주/CPU 스파이크 없이 안정적으로 동작한다.
6. (Mock 금지) Given 본 스토리 검증을 수행할 때, Then sidecar는 반드시 `Mode: real`이어야 하며, `Mode: mock`이면 **Acceptance Criteria 미충족(FAIL)** 으로 처리한다.
7. (Startup 스냅샷) Given Boothy/sidecar가 기동될 때, Then `reason=startup`인 `boothy-camera-status` 스냅샷이 1회 이상 전달되어(기동 후 **2초 이내**) `mode`, `sdk.initialized`, `sdk.diagnostic`가 즉시 확인 가능하다.
8. (프론트 폴링 의존 제거) Given Frontend가 리로드/스톨되더라도, Then Boothy(Tauri backend)가 상태 갱신 트리거를 유지한다(예: `camera.getStatus`를 **최대 5초 간격**으로 폴링/감시) 그리고 상태 변화 시 UI가 복구되면 즉시 최신 상태를 반영할 수 있다.
   - [Source: `docs/problem_history/2026-01-30-camera-lamp-power-cycle-stuck.md`]

## Tasks / Subtasks

- [x] 프로토콜/이벤트 계약 추가 (AC: 1, 2, 3, 5, 6, 7)
  - [x] sidecar 이벤트 `event.camera.statusChanged` 추가(정답 스냅샷)
  - [x] Tauri에서 `event.camera.statusChanged`를 `boothy-camera-status`로 브릿지
  - [ ] 프로토콜 버전 minor bump 및 후방 호환 유지(구버전은 폴링/힌트만)
  - [x] 이벤트 이름을 명확히 고정:
    - `boothy-camera-status`: **정답 스냅샷**(UI가 pull 없이 렌더링 가능)
    - `boothy-camera-status-hint`: **refresh 힌트**(기존 호환/폴백)
  - [x] (구현 위치 고정) `apps/camera-sidecar/Program.cs`, `apps/boothy/src-tauri/src/camera/ipc_client.rs`
- [x] Boothy(Tauri): Backend 주도 상태 갱신 트리거 유지 (AC: 8)
  - [x] Frontend와 무관하게 `camera.getStatus`를 주기적으로 호출해 트리거가 끊기지 않도록 유지(예: ≤5초)
  - [x] 상태 변화 감지 시 `boothy-camera-status-hint` emit(기존 동작 유지; 스냅샷 이벤트 도입 전까지 UI pull 트리거)
  - [x] (구현 위치 고정) `apps/boothy/src-tauri/src/camera/ipc_client.rs`
- [x] AC-4(2.5초 타임아웃 + 강제 복구) 경로를 “스펙/태스크/검증”으로 고정 (AC: 4)
  - [x] Sidecar: `camera.getStatus` watchdog(2.5s) 동작 유지/검증
    - (현행 근거) `apps/camera-sidecar/Program.cs`의 `HandleGetStatusAsync`: `timeoutMs=2500` + Timeout 응답 후 `Environment.Exit(2)`
  - [x] Boothy: IPC timeout/채널 종료 시 sidecar 재시작(강제 복구) 동작 유지/검증
    - (현행 근거) `apps/boothy/src-tauri/src/camera/ipc_client.rs`: IPC timeout 시 `stop_sidecar()`
    - (현행 근거) `apps/boothy/src-tauri/src/main.rs`: `boothy_camera_get_status`에서 sidecar 부트스트랩 + 자동 재시작 경로 존재
  - [x] 타임아웃 정렬: “sidecar 내부 watchdog(2.5s)”과 “Tauri 요청 timeout(예: 3s)”이 서로를 방해하지 않도록 수치/로그를 정리(최소한 원인 식별 가능하게)
  - [x] 검증 합격 기준을 로그 기반으로 명문화(Testing 섹션 참조)
- [x] Sidecar: 레퍼런스 패턴(이벤트→재열거) 구현 (AC: 1, 2, 5, 6, 7)
  - [x] digiCamControl의 “이벤트 → 즉시 재열거 → 상태 확정” 구현을 그대로 활용(가능하면 동일한 흐름/동일한 책임 분리 유지)
  - [x] cameraAdded / shutdown / internalError / OS device hint 수신 시 enumerate로 즉시 전이
  - [x] enumerate 결과로 상태를 확정하고 `statusChanged` emit
  - [x] “동일 스냅샷 반복 emit 금지” + `seq` 단조 증가
  - [x] (코얼레싱 스펙) `probeInFlight`는 1개만 허용, 힌트 연속 수신은 `deviceHint.debounceMs`(기본 500ms)로 디바운스 후 1회만 실행
  - [x] (권장 파라미터) `probe.timeoutMs=2000`, `statusChanged.minIntervalMs=250`
  - [x] (구현 위치 고정) `apps/camera-sidecar/Camera/RealCameraController.cs`
- [x] Sidecar: headless 이벤트 전달 조건 제공(현장 핵심) (AC: 1, 2, 5, 7)
  - [x] `BOOTHY_EDSDK_PUMP_MODE=messageLoop|edsGetEvent|both` 구현/문서화
  - [x] 기본값은 내부 배포에서 가장 보수적인 값으로 설정(결정: `both`)
  - [x] 메시지 루프/STA 또는 이벤트 펌프가 실제로 cameraAdded를 전달하는지 검증 로그 추가
  - [x] (권장 파라미터) `pump.boostWindowMs=10000`, `pump.lowIntervalMs=500`, `pump.highIntervalMs=100~200`
- [x] Sidecar: OS device hint source 도입(레퍼런스 우선) (AC: 1, 2, 5)
  - [ ] 1순위: WIA 기반 device connected/disconnected 이벤트(레퍼런스와 동일한 역할)
  - [x] 2순위: WMI 또는 Win32 알림 fallback(현장 호환 고려)
  - [x] 디바운스(기본 500ms) 및 probe 코얼레싱 적용
- [x] UI: 램프 렌더링 소스 전환 (AC: 1, 2, 3, 5, 6, 7)
  - [x] `boothy-camera-status`(스냅샷) 기반으로 램프를 렌더링
  - [x] `boothy-camera-status-hint`는 폴백(필요 시 getStatus 1회 트리거)로만 유지
  - [x] (구현 위치 고정) 이벤트 리스너/상태 갱신: `apps/boothy/src/App.tsx`
  - [x] (구현 위치 고정) 램프/메시지 렌더링(사용부): `apps/boothy/src/components/panel/MainLibrary.tsx`, `apps/boothy/src/components/panel/CameraControlsPanel.tsx`
  - [x] (F5/리로드 오탐지 방지) `apps/boothy/src/tauriMock.ts`: mockIPC는 DEV + 명시적 opt-in에서만 활성화(기본 비활성)
- [ ] 검증/리그 테스트 (AC: 1, 2, 3, 4, 5, 6, 7, 8)
  - [ ] 히스토리 문서 시나리오(A/B)를 각 10회 반복 실행
  - [ ] 환경 오류 시나리오(C: EDSDK 아키텍처 불일치/미존재)에서 `mode`, `sdk.diagnostic` 즉시 식별 가능 여부 확인
  - [ ] “Mode: mock” 발생 시 원인 식별이 가능한지 확인
  - [ ] 로그에서 “hint → probe → statusChanged” 흐름이 남는지 확인(상관관계 id 포함)
  - [ ] Boothy 로그에서 `camera.getStatus`가 “딱 1회”로 끝나지 않고 주기적으로 호출되는지 확인(Frontend 리로드 여부와 무관)

## Dev Notes

### Story ID

- epic-4.story-4.4

### References

- `docs/architecture/camera-status-realtime.md`
- `docs/problem_history/2026-01-30-camera-lamp-power-cycle-stuck.md`
- (레퍼런스 근거) `reference/camerafunction/digiCamControl-2.0.0/CameraControl.Devices/CameraDeviceManager.cs`
- (레퍼런스 근거) `reference/camerafunction/digiCamControl-2.0.0/Canon.Eos.Framework/EosFramework.cs`

### Source Tree (관련 코드 위치)

- Sidecar(.NET): `apps/camera-sidecar/*` (특히 `apps/camera-sidecar/Program.cs`, `apps/camera-sidecar/Camera/RealCameraController.cs`)
- Tauri(Rust): `apps/boothy/src-tauri/src/camera/*` (특히 `apps/boothy/src-tauri/src/camera/ipc_client.rs`)
- UI(React): `apps/boothy/src/*` (특히 `apps/boothy/src/App.tsx`)

### Testing Standards (관련)

- UI(React): `apps/boothy`는 `vitest` + `@testing-library/react`를 사용한다. 새 이벤트(`boothy-camera-status`) 도입 시, 최소한 “이벤트 수신 → 상태 갱신 → 램프/메시지 렌더링”이 깨지지 않는 스모크 테스트를 추가/보강한다(필요 시 기존 `apps/boothy/src/components/panel/__tests__/*` 패턴 참고).
- Tauri(Rust): `apps/boothy/src-tauri`는 `cargo test`로 단위 테스트 실행이 가능하다(IPC/상태 머신 로직은 가능하면 순수 함수로 분리해 테스트 가능하게 유지).
- Sidecar(.NET): 현재는 단위 테스트 프로젝트가 없으므로(현장 이슈 성격상) 로그 기반 수동 검증(본 문서 Testing 섹션)을 “MVP Gate”로 삼는다.

### Ground Truth Rules (고정 규칙)

아래는 “아이디어”가 아니라 **구현 규칙**으로 고정한다.

- RULE-1: `cameraAdded`(또는 OS device added 힌트)를 받으면, **지연 없이 probe(enumerate)로 전이**한다.
- RULE-2: 상태는 힌트로 단정하지 않고 **probe 결과로 확정**한다(스냅샷).
- RULE-3: `shutdown/internalError`를 받으면 즉시 세션을 닫고 **NoCamera 스냅샷을 확정**한다.
- RULE-4: headless 환경에서도 RULE-1~3이 성립하도록, sidecar에 **이벤트 전달 조건(메시지 루프/STA 또는 강제 펌프)** 을 제공한다.
  - [Source: `docs/architecture/camera-status-realtime.md`]

### Reference Mapping (digiCamControl → Boothy)

레퍼런스(digiCamControl)의 구현/동작을 Boothy 컴포넌트에 대응시킨다(가능한 그대로 활용, 변경 최소화).

- digiCamControl의 `EosFramework.CameraAdded`(EDSDK CameraAdded 핸들러) → sidecar의 “카메라 추가/핫플러그 힌트 수신” 트리거
  - [Source: `reference/camerafunction/digiCamControl-2.0.0/Canon.Eos.Framework/EosFramework.cs`]
- digiCamControl의 `CameraDeviceManager._framework_CameraAdded` → 즉시 `AddCanonCameras()`/`GetCameraCollection()`(재열거) → 상태 확정
  - [Source: `reference/camerafunction/digiCamControl-2.0.0/CameraControl.Devices/CameraDeviceManager.cs`]
- 위 구현을 Boothy에서는 “hint/event → enumerate → statusChanged 스냅샷 push”로 연결한다(핵심 흐름 유지).
  - [Source: `docs/architecture/camera-status-realtime.md`]

### Validation Notes (로그 관찰 팁)

- Sidecar 로그는 UTC, Boothy 로그는 로컬 시간일 수 있으므로 동일 사건은 `correlationId`/이벤트명으로 묶어 해석한다.
- 로그 경로 예시:
  - Sidecar: `%APPDATA%\\Boothy\\logs\\boothy-sidecar-YYYYMMDD.log`
  - Boothy: `%APPDATA%\\Boothy\\logs\\boothy-YYYYMMDD.log`
  - [Source: `docs/problem_history/2026-01-30-camera-lamp-power-cycle-stuck.md`]

### Summary

현장 이슈(전원 OFF/ON, ON/OFF/ON)에서 UI 램프가 stale 상태로 고착되는 문제를 해결하기 위해,
`reference/camerafunction/digiCamControl-2.0.0`의 **“이벤트 → 즉시 재열거(enumerate) → 상태 확정”** 구현을 Boothy sidecar/headless 환경에서 **가능한 그대로 활용**하고, Boothy 요구사항에 필요한 최소 래핑/어댑터만 추가한다.

핵심 산출물:
- Sidecar → Tauri → UI로 **정답 스냅샷 이벤트(`statusChanged`)를 push**하여 램프를 pull(getStatus) 의존에서 분리
- headless sidecar에서도 cameraAdded/shutdown 콜백이 들어오도록 **메시지 루프/STA 또는 강제 이벤트 펌프** 제공
- “Mode: mock” 및 EDSDK 로드 실패를 **진단 스냅샷으로 즉시 표면화**

⚠️ **중요(본 스토리 고정 조건): Story 4.4는 mock을 허용하지 않는다.**  
sidecar가 `Mode: mock`이면 “진단 성공”이 아니라 **환경 미충족(블로커)** 으로 처리하고 스토리를 완료로 인정하지 않는다.

### Status Model (UI 램프 기준)

본 스토리에서 UI는 `boothy-camera-status`(정답 스냅샷) 기반으로만 램프를 렌더링한다.

- 내부 상태(`state`):
  - `noCamera`
  - `connecting`
  - `ready`
  - `error`
- 램프 매핑(기본):
  - 빨강 = `noCamera` 또는 `error`
  - 초록 = `ready`
  - (선택) 노랑 = `connecting`

### Protocol Contract (정답 스냅샷: `event.camera.statusChanged`)

Sidecar는 상태 변화가 관측될 때 `event.camera.statusChanged`를 emit하고, Tauri는 이를 `boothy-camera-status`로 그대로 브릿지한다.

Payload(권장, `docs/architecture/camera-status-realtime.md` 준수):
```json
{
  "seq": 123,
  "observedAt": "2026-01-31T00:00:00.000Z",
  "reason": "startup|probe|cameraAdded|shutdown|pnpAdded|pnpRemoved|sdkReset|ipcTimeout",
  "mode": "real|mock",
  "sdk": {
    "initialized": true,
    "diagnostic": null,
    "resolvedPath": "C:\\\\...\\\\edsdk\\\\EDSDK.dll",
    "platform": "x86|x64"
  },
  "state": "noCamera|connecting|ready|error",
  "connected": true,
  "cameraDetected": true,
  "cameraReady": true,
  "cameraCount": 1,
  "cameraModel": "Canon EOS ..."
}
```

Emit 규칙(폭주/중복 방지):
- `seq`는 단조 증가
- “동일 스냅샷 반복”은 emit 생략(로그/이벤트 폭주 방지)
- 단, `sdk.diagnostic` 신규 발생(예: real 모드 불가 진단)은 1회 emit 허용(현장 디버깅 목적)
- (권장) `statusChanged.minIntervalMs`(기본 250ms)로 과도한 emit 방지
- ⚠️ 본 스토리 완료 기준에서 `mode=mock`은 **FAIL**

### Non-Functional Requirements

- NFR-1: EDSDK 호출은 동시/병렬 호출 금지(단일 컨텍스트로 serialize)
- NFR-2: 이벤트 폭주가 UI/로그를 망치지 않도록 디바운스/코얼레싱 필수
- NFR-3: Offline(네트워크 차단) 환경에서 동일하게 동작

### Dependencies

- (필수) sidecar/Tauri IPC 기반이 존재해야 함(이미 `camera.getStatus`/`statusHint` 등 경로가 있는 상태)
- (필수) Canon EDSDK DLL 배치/번들링 정책이 내부 배포에서 충족되어야 함(“Mode: mock” 방지 및 진단 표면화 포함)
- (필수) digiCamControl 오픈소스 활용에 대한 컴플라이언스(라이선스/고지/소스 제공 방식) 합의 및 반영
- (권장) Story 4.1이 선행되면 좋으나, **본 스토리(4.4)는 촬영/전송보다 “상태/재연결”이 목적이므로 선행 구현 가능**

### Pre-flight (Go / No-Go)

Story 4.4 구현/검증을 시작하기 전 아래를 로그로 확인한다. 하나라도 No-Go면 4.4는 즉시 중단(환경 해결 후 재개).

**Go 조건**
- sidecar 로그에 `Mode: real`
- sidecar 로그에 `Canon EDSDK initialized`(또는 동등한 초기화 성공 로그)
- Boothy 로그에 `camera.getStatus` 요청/응답이 관측된다(초기 핸드셰이크/폴러 정상)

**No-Go(블로커)**
- `Mode: mock`
- `EDSDK load failed` / `EDSDK architecture mismatch` / `ResolvedPath=none` 등 real 모드 불가 진단
- `camera.getStatus`가 지속적으로 timeout/재시작 루프만 발생하고 정상 스냅샷이 만들어지지 않음(먼저 EDSDK/드라이버/점유 앱 등 환경 문제 해결)

### Readiness Checkpoints (Definition of Ready)

1. **스펙 문서가 구현 지시 수준으로 확정**
   - `docs/architecture/camera-status-realtime.md`의 “RULE-1~4” 및 `statusChanged` payload/emit 규칙이 구현 가능하게 확정됨
2. **현장 검증 장비/시나리오가 준비됨**
   - 전원 사이클(OFF→ON, ON→OFF→ON) 반복 테스트가 가능한 리그(케이블/허브 포함)
3. **오픈소스 활용 방식/컴플라이언스 합의**
   - `reference/camerafunction/digiCamControl-2.0.0` 구현을 최대한 그대로 활용(변경 최소화)
   - 배포물에 포함될 라이선스/고지/소스 제공 방식이 결정되어 있음
4. **실카메라 환경 준비(필수)**
   - sidecar가 `Mode: real`로 실행 가능(Pre-flight Go 조건 충족)

### Risks / Notes

- 레퍼런스는 WPF 메시지 루프 환경을 전제로 동작할 가능성이 높아, headless에서 동일 조건을 제공하는 작업이 핵심 리스크/핵심 해결책이다.
- `reference/camerafunction/digiCamControl-2.0.0` 구현을 그대로 활용하는 만큼, **라이선스 컴플라이언스(고지/소스 제공 등)** 가 전제이며 “변경 최소화”가 유지보수/추적성에 중요하다.

### Rollback / Recovery

- `BOOTHY_EDSDK_PUMP_MODE` 플래그로 messageLoop/edsGetEvent/both 전환 가능하게 유지(문제 시 즉시 롤백)
- `statusChanged` 미지원/불안정 시, 기존 폴링(`camera.getStatus`) + 힌트 기반 갱신으로 폴백 유지

## Testing

### Minimum Validation (Must Pass)

- 시나리오 A(OFF→ON): 10초 내 초록 복귀 + 로그에서 “hint → probe → statusChanged(ready)” 흐름 확인(**10회 중 10회**)
- 시나리오 B(ON→OFF→ON): OFF는 1초 내 빨강, ON은 10초 내 초록 복귀(**10회 중 10회**)
- 시나리오 C(환경 오류): 램프는 빨강 + admin 진단에 `mode`, `sdk.diagnostic`가 즉시 표시
- `boothy-camera-status` 이벤트가 상태 변화 시점에 push되어 UI가 pull 없이도 갱신
- 시나리오 D(AC-4: hang/timeout 복구): `camera.getStatus`가 멈추는 상황에서 아래 로그/행동이 관측되어야 함
  - Sidecar 로그: `camera.getStatus exceeded 2500ms; returning Timeout and terminating sidecar for recovery` (correlation id 포함)
  - Boothy(Tauri) 로그: `IPC timeout during camera.getStatus - restarting sidecar` 또는 동등한 “강제 재시작” 로그가 남고, 이후 상태가 다시 관측됨
- “Mode: mock/EDSDK 로드 실패”가 발생하면 원인이 즉시 표면화(로그/진단)되며, **특히 `Mode: mock`은 즉시 FAIL 처리**
- 이벤트 폭주 없이 CPU/로그가 안정적(디바운스/코얼레싱 확인)
- (트리거 연속성) Boothy 로그에서 `camera.getStatus` 요청이 주기적으로 관측됨(예: ≤5초). “딱 1회 호출 후 정지” 패턴이 재발하지 않음.

## Change Log

| Date       | Version | Description                                              | Author    |
| ---------- | ------- | -------------------------------------------------------- | --------- |
| 2026-01-31 | 0.1     | 스토리 템플릿 섹션 정리(Status/Story/Tasks/Testing 등) | Sarah (PO) |
| 2026-01-31 | 0.2     | 레퍼런스 기반 보완(RCA/프론트 의존 제거/AC·Tasks 강화) | Bob (SM) |
| 2026-01-31 | 0.3     | 검증 결과 반영(AC-4 태스크/검증 고정, 이벤트 명확화, 오픈소스 활용 원칙 반영) | Sarah (PO) |
| 2026-01-31 | 0.4     | 구현(상태 스냅샷 이벤트/브릿지/램프 렌더링 전환/코얼레싱/프로토콜 1.0.0 유지) | James (dev) |
| 2026-02-01 | 0.5     | F5/리로드 시 tauri mock 오탐지 방지 + unit test 추가 | James (dev) |

## Dev Agent Record

### Agent Model Used

GPT-5.2 (Codex CLI)

### Debug Log References

- N/A

### Completion Notes List

- Sidecar→Tauri→UI로 `event.camera.statusChanged` → `boothy-camera-status` 스냅샷 push 경로 추가
- Sidecar: `cameraAdded`/`shutdown`/`internalError`/OS device hint에서 probe(재열거) 트리거 + 디바운스/코얼레싱 적용
- Sidecar: `BOOTHY_EDSDK_PUMP_MODE=messageLoop|edsGetEvent|both` 지원(기본 both) + boost window 파라미터 지원
- UI: 고객 모드 램프는 `boothy-camera-status`(push) 우선 렌더링, `boothy-camera-status-hint`는 pull(getStatus) 폴백으로만 사용
- UI: `apps/boothy/src/tauriMock.ts`는 기본적으로 mock 비활성(DEV에서만 `VITE_BOOTHY_ENABLE_TAURI_MOCKS=true` 또는 `?boothyMockTauri=1`로 opt-in)
- 미해결(수동): Testing 섹션의 시나리오 A/B/C/D 리그 테스트(각 10회) 및 로그 기반 합격 판정

### File List

- `apps/camera-sidecar/Camera/DeviceChangeWatcher.cs` (added)
- `apps/camera-sidecar/Camera/ICameraController.cs` (modified)
- `apps/camera-sidecar/Camera/MockCameraController.cs` (modified)
- `apps/camera-sidecar/Camera/RealCameraController.cs` (modified)
- `apps/camera-sidecar/IPC/IpcMessage.cs` (modified)
- `apps/camera-sidecar/IPC/NamedPipeServer.cs` (modified)
- `apps/camera-sidecar/Program.cs` (modified)
- `apps/boothy/src-tauri/src/camera/ipc_client.rs` (modified)
- `apps/boothy/src-tauri/src/camera/ipc_models.rs` (modified)
- `apps/boothy/src/App.tsx` (modified)
- `apps/boothy/src/tauriMock.ts` (modified)
- `apps/boothy/src/tauriMockConfig.ts` (added)
- `apps/boothy/src/__tests__/tauriMockConfig.test.ts` (added)
- `apps/boothy/src/components/ui/AppProperties.tsx` (modified)
- `apps/boothy/src/components/panel/MainLibrary.tsx` (modified)
- `apps/boothy/src/components/panel/CameraControlsPanel.tsx` (modified)

## QA Results

N/A (미구현)
